//! Tsuchinoko CLI - Python to Rust Transpiler
//!
//! Author: Tane Channel Technology

use anyhow::Result;
use clap::Parser;
use std::path::PathBuf;
use tsuchinoko::transpile;

/// Tsuchinoko - Python to Rust Transpiler
#[derive(Parser, Debug)]
#[command(name = "tnk")]
#[command(author = "Tane Channel Technology")]
#[command(version = env!("CARGO_PKG_VERSION"))]
#[command(about = "Transpile Python code to Rust", long_about = None)]
struct Cli {
    /// Input Python file
    #[arg(value_name = "INPUT")]
    input: PathBuf,

    /// Output Rust file (default: <INPUT>.rs)
    #[arg(short, long, value_name = "OUTPUT")]
    output: Option<PathBuf>,

    /// Generate a complete Rust project folder
    #[arg(short, long, value_name = "PROJECT_NAME")]
    project: Option<String>,

    /// Show debug information
    #[arg(short, long)]
    debug: bool,

    /// Check only (don't generate output)
    #[arg(short, long)]
    check: bool,

    /// PyO3 version for generated project (default: "0" = latest major)
    #[arg(long, default_value = "0")]
    pyo3_version: String,
}

fn main() -> Result<()> {
    let cli = Cli::parse();

    if cli.debug {
        println!("[DEBUG] Input: {:?}", cli.input);
        println!("[DEBUG] Output: {:?}", cli.output);
        println!("[DEBUG] Project: {:?}", cli.project);
    }

    // Read input file
    let source = std::fs::read_to_string(&cli.input)?;

    if cli.debug {
        println!("[DEBUG] Source length: {} bytes", source.len());
    }

    // Transpile Python to Rust
    let rust_code = transpile(&source)?;

    if cli.debug {
        println!("[DEBUG] Generated Rust code:");
        println!("{rust_code}");
    }

    // Check mode
    if cli.check {
        println!("✅ Transpilation successful!");
        return Ok(());
    }

    // Project generation mode
    if let Some(project_name) = &cli.project {
        generate_project(project_name, &rust_code, &cli.pyo3_version)?;
        println!("✅ Generated project: {project_name}/");
        println!("   Run: cd {project_name} && cargo build --release");
        return Ok(());
    }

    // Single file transpilation
    let output_path = cli.output.unwrap_or_else(|| {
        // Default: output to current directory with same filename.rs
        let mut p = cli.input.clone();
        p.set_extension("rs");
        // If input has a path, use just the filename in current dir
        if let Some(filename) = p.file_name() {
            std::path::PathBuf::from(filename)
        } else {
            p
        }
    });

    std::fs::write(&output_path, &rust_code)?;
    println!("✅ Transpiled to: {output_path:?}");

    Ok(())
}

/// Generate a complete Rust project
fn generate_project(name: &str, rust_code: &str, pyo3_version: &str) -> Result<()> {
    use std::fs;

    // Extract just the project name from path (e.g., "tmp/myproj" -> "myproj")
    let project_name = std::path::Path::new(name)
        .file_name()
        .and_then(|s| s.to_str())
        .unwrap_or(name);

    // Create project directory
    fs::create_dir_all(format!("{name}/src"))?;

    // Check dependencies
    let uses_pyo3 = rust_code.contains("use pyo3");
    let uses_serde = rust_code.contains("serde");
    let uses_bridge = rust_code.contains("PythonBridge");

    let mut dependencies = String::new();

    // Minimal dependencies (no tsuchinoko - self-contained project)
    if uses_serde || uses_bridge {
        dependencies.push_str("serde = { version = \"1.0\", features = [\"derive\"] }\n");
        dependencies.push_str("serde_json = \"1.0\"\n");
    }

    if uses_pyo3 {
        dependencies.push_str(&format!("pyo3 = {{ version = \"{pyo3_version}\", features = [\"auto-initialize\"] }}\n"));
    }
    
    let cargo_toml = format!(
        r#"[package]
name = "{project_name}"
version = "0.1.0"
edition = "2021"

[dependencies]
{dependencies}"#
    );
    fs::write(format!("{name}/Cargo.toml"), cargo_toml)?;

    // Create .gitignore
    let gitignore = "/target\n";
    fs::write(format!("{name}/.gitignore"), gitignore)?;

    // If using PythonBridge, generate embedded bridge module
    if uses_bridge {
        let bridge_rs = generate_bridge_module();
        fs::write(format!("{name}/src/bridge.rs"), bridge_rs)?;
    }

    // Create main.rs with transpiled code
    // Replace tsuchinoko::bridge with local bridge module
    let fixed_code = rust_code.replace("use tsuchinoko::bridge::PythonBridge;", "mod bridge;\nuse bridge::PythonBridge;");
    let fixed_code = fixed_code.replace("tsuchinoko::bridge::PythonBridge", "bridge::PythonBridge");
    
    let main_rs = format!(
        r#"// Generated by Tsuchinoko - Python to Rust Transpiler
// Author: Tane Channel Technology

{fixed_code}
"#
    );
    fs::write(format!("{name}/src/main.rs"), main_rs)?;

    Ok(())
}

/// Generate self-contained bridge module for PythonBridge
fn generate_bridge_module() -> String {
    // Embed worker.py as a string constant
    let worker_py = include_str!("bridge/worker.py");
    
    // Build bridge.rs using string concatenation to avoid format! escaping issues
    let mut code = String::new();
    code.push_str("//! PythonBridge - Self-contained module for Resident Python Worker\n");
    code.push_str("//! Generated by Tsuchinoko\n\n");
    code.push_str("use std::io::{BufRead, BufReader, Write};\n");
    code.push_str("use std::process::{Child, Command, Stdio};\n");
    code.push_str("use std::sync::atomic::{AtomicU64, Ordering};\n\n");
    code.push_str("/// Embedded Python worker code\n");
    // Use r#####"..."##### to safely embed Python code containing """, #, etc.
    code.push_str("const WORKER_CODE: &str = r#####\"\n");
    code.push_str(worker_py);
    code.push_str("\"#####;\n\n");
    // Add display_value helper function
    code.push_str("/// Display serde_json::Value in human-readable format\n");
    code.push_str("/// For Value::String, return the content without quotes\n");
    code.push_str("pub fn display_value(value: &serde_json::Value) -> String {\n");
    code.push_str("    match value {\n");
    code.push_str("        serde_json::Value::String(s) => s.clone(),\n");
    code.push_str("        other => other.to_string(),\n");
    code.push_str("    }\n");
    code.push_str("}\n\n");
    // Add PythonBridge implementation
    code.push_str(r#"/// Python worker communication manager
pub struct PythonBridge {
    process: Child,
    request_id: AtomicU64,
}

impl PythonBridge {
    /// Start Python worker
    pub fn new() -> Result<Self, String> {
        let process = Command::new("python")
            .args(["-u", "-c", WORKER_CODE])
            .stdin(Stdio::piped())
            .stdout(Stdio::piped())
            .stderr(Stdio::inherit())
            .spawn()
            .map_err(|e| format!("Failed to spawn Python worker: {}", e))?;

        Ok(Self {
            process,
            request_id: AtomicU64::new(1),
        })
    }

    fn send_request(&mut self, request: serde_json::Value) -> Result<serde_json::Value, String> {
        let stdin = self.process.stdin.as_mut()
            .ok_or("Failed to get stdin")?;
        writeln!(stdin, "{}", request.to_string())
            .map_err(|e| format!("Failed to write to stdin: {}", e))?;
        stdin.flush()
            .map_err(|e| format!("Failed to flush stdin: {}", e))?;

        let stdout = self.process.stdout.as_mut()
            .ok_or("Failed to get stdout")?;
        let mut reader = BufReader::new(stdout);
        let mut line = String::new();
        reader.read_line(&mut line)
            .map_err(|e| format!("Failed to read from stdout: {}", e))?;

        let response: serde_json::Value = serde_json::from_str(&line)
            .map_err(|e| format!("Failed to parse response: {}", e))?;

        if response["ok"].as_bool() == Some(true) {
            Ok(response["result"].clone())
        } else {
            Err(format!("Python error: {}", response["error"]))
        }
    }

    fn call_raw(&mut self, target: &str, args: &[serde_json::Value]) -> Result<serde_json::Value, String> {
        let id = self.request_id.fetch_add(1, Ordering::SeqCst);
        let request = serde_json::json!({
            "id": id,
            "op": "call",
            "target": target,
            "args": args,
        });

        self.send_request(request)
    }

    pub fn call_i64(&mut self, target: &str, args: &[serde_json::Value]) -> Result<i64, String> {
        let result = self.call_raw(target, args)?;
        result.as_i64().ok_or_else(|| format!("Expected i64, got: {}", result))
    }

    pub fn call_f64(&mut self, target: &str, args: &[serde_json::Value]) -> Result<f64, String> {
        let result = self.call_raw(target, args)?;
        result.as_f64().ok_or_else(|| format!("Expected f64, got: {}", result))
    }

    pub fn call_string(&mut self, target: &str, args: &[serde_json::Value]) -> Result<String, String> {
        let result = self.call_raw(target, args)?;
        result.as_str().map(|s| s.to_string()).ok_or_else(|| format!("Expected string, got: {}", result))
    }

    pub fn call_vec_i64(&mut self, target: &str, args: &[serde_json::Value]) -> Result<Vec<i64>, String> {
        let result = self.call_raw(target, args)?;
        result.as_array()
            .ok_or_else(|| format!("Expected array, got: {}", result))?
            .iter()
            .map(|v| v.as_i64().ok_or_else(|| format!("Expected i64 in array, got: {}", v)))
            .collect()
    }

    pub fn call_vec_f64(&mut self, target: &str, args: &[serde_json::Value]) -> Result<Vec<f64>, String> {
        let result = self.call_raw(target, args)?;
        result.as_array()
            .ok_or_else(|| format!("Expected array, got: {}", result))?
            .iter()
            .map(|v| v.as_f64().ok_or_else(|| format!("Expected f64 in array, got: {}", v)))
            .collect()
    }

    pub fn call_json<T: serde::de::DeserializeOwned>(&mut self, target: &str, args: &[serde_json::Value]) -> Result<T, String> {
        let result = self.call_raw(target, args)?;
        serde_json::from_value(result).map_err(|e| format!("Type conversion failed: {}", e))
    }

    pub fn call_json_method<T: serde::de::DeserializeOwned>(
        &mut self,
        handle: serde_json::Value,
        method: &str,
        args: &[serde_json::Value],
    ) -> Result<T, String> {
        let id = self.request_id.fetch_add(1, Ordering::SeqCst);
        let request = serde_json::json!({
            "id": id,
            "op": "method",
            "handle": handle,
            "method": method,
            "args": args,
        });

        let result = self.send_request(request)?;
        serde_json::from_value(result).map_err(|e| format!("Method result type conversion failed: {}", e))
    }

    pub fn shutdown(&mut self) -> Result<(), String> {
        let id = self.request_id.fetch_add(1, Ordering::SeqCst);
        let request = serde_json::json!({
            "id": id,
            "op": "shutdown",
        });

        if let Some(stdin) = self.process.stdin.as_mut() {
            let _ = writeln!(stdin, "{}", request.to_string());
            let _ = stdin.flush();
        }

        self.process.wait().map_err(|e| format!("Failed to wait for worker: {}", e))?;
        Ok(())
    }
}

impl Drop for PythonBridge {
    fn drop(&mut self) {
        let _ = self.shutdown();
    }
}
"#);
    code
}
