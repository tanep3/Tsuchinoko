//! Tsuchinoko CLI - Python to Rust Transpiler
//!
//! Author: Tane Channel Technology

use anyhow::Result;
use clap::Parser;
use std::path::PathBuf;
use tsuchinoko::transpile;

/// Tsuchinoko - Python to Rust Transpiler
#[derive(Parser, Debug)]
#[command(name = "tnk")]
#[command(author = "Tane Channel Technology")]
#[command(version = env!("CARGO_PKG_VERSION"))]
#[command(about = "Transpile Python code to Rust", long_about = None)]
struct Cli {
    /// Input Python file
    #[arg(value_name = "INPUT")]
    input: PathBuf,

    /// Output Rust file (default: <INPUT>.rs)
    #[arg(short, long, value_name = "OUTPUT")]
    output: Option<PathBuf>,

    /// Generate a complete Rust project folder
    #[arg(short, long, value_name = "PROJECT_NAME")]
    project: Option<String>,

    /// Show debug information
    #[arg(short, long)]
    debug: bool,

    /// Check only (don't generate output)
    #[arg(short, long)]
    check: bool,

    /// PyO3 version for generated project (default: "0" = latest major)
    #[arg(long, default_value = "0")]
    pyo3_version: String,
}

fn main() -> Result<()> {
    let cli = Cli::parse();

    if cli.debug {
        println!("[DEBUG] Input: {:?}", cli.input);
        println!("[DEBUG] Output: {:?}", cli.output);
        println!("[DEBUG] Project: {:?}", cli.project);
    }

    // Read input file
    let source = std::fs::read_to_string(&cli.input)?;

    if cli.debug {
        println!("[DEBUG] Source length: {} bytes", source.len());
    }

    // Transpile Python to Rust
    let rust_code = transpile(&source)?;

    if cli.debug {
        println!("[DEBUG] Generated Rust code:");
        println!("{rust_code}");
    }

    // Check mode
    if cli.check {
        println!("✅ Transpilation successful!");
        return Ok(());
    }

    // Project generation mode
    if let Some(project_name) = &cli.project {
        generate_project(project_name, &rust_code, &cli.pyo3_version)?;
        println!("✅ Generated project: {project_name}/");
        println!("   Run: cd {project_name} && cargo build --release");
        return Ok(());
    }

    // Single file transpilation
    let output_path = cli.output.unwrap_or_else(|| {
        // Default: output to current directory with same filename.rs
        let mut p = cli.input.clone();
        p.set_extension("rs");
        // If input has a path, use just the filename in current dir
        if let Some(filename) = p.file_name() {
            std::path::PathBuf::from(filename)
        } else {
            p
        }
    });

    std::fs::write(&output_path, &rust_code)?;
    println!("✅ Transpiled to: {output_path:?}");

    Ok(())
}

/// Generate a complete Rust project
fn generate_project(name: &str, rust_code: &str, pyo3_version: &str) -> Result<()> {
    use std::fs;

    // Extract just the project name from path (e.g., "tmp/myproj" -> "myproj")
    let project_name = std::path::Path::new(name)
        .file_name()
        .and_then(|s| s.to_str())
        .unwrap_or(name);

    // Create project directory
    fs::create_dir_all(format!("{name}/src"))?;

    // Check if PyO3 is needed (used in the generated code)
    let uses_pyo3 = rust_code.contains("use pyo3::prelude::*");
    
    // Create Cargo.toml with appropriate dependencies
    let dependencies = if uses_pyo3 {
        format!(r#"pyo3 = {{ version = "{pyo3_version}", features = ["auto-initialize"] }}
"#)
    } else {
        String::new()
    };
    
    let cargo_toml = format!(
        r#"[package]
name = "{project_name}"
version = "0.1.0"
edition = "2021"

[dependencies]
{dependencies}"#
    );
    fs::write(format!("{name}/Cargo.toml"), cargo_toml)?;

    // Create .gitignore
    let gitignore = "/target\n";
    fs::write(format!("{name}/.gitignore"), gitignore)?;

    // Create main.rs with transpiled code
    // The transpiled code already contains a main() function, so we just add a header
    let main_rs = format!(
        r#"// Generated by Tsuchinoko - Python to Rust Transpiler
// Author: Tane Channel Technology

{rust_code}
"#
    );
    fs::write(format!("{name}/src/main.rs"), main_rs)?;

    Ok(())
}
