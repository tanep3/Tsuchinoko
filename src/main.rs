//! Tsuchinoko CLI - Python to Rust Transpiler
//!
//! Author: Tane Channel Technology

use clap::Parser;
use std::path::PathBuf;
use anyhow::Result;
use tsuchinoko::transpile;

/// Tsuchinoko - Python to Rust Transpiler
#[derive(Parser, Debug)]
#[command(name = "tnk")]
#[command(author = "Tane Channel Technology")]
#[command(version = "0.5.0")]
#[command(about = "Transpile Python code to Rust", long_about = None)]
struct Cli {
    /// Input Python file
    #[arg(value_name = "INPUT")]
    input: PathBuf,

    /// Output Rust file (default: <INPUT>.rs)
    #[arg(short, long, value_name = "OUTPUT")]
    output: Option<PathBuf>,

    /// Generate a complete Rust project folder
    #[arg(short, long, value_name = "PROJECT_NAME")]
    project: Option<String>,

    /// Show debug information
    #[arg(short, long)]
    debug: bool,

    /// Check only (don't generate output)
    #[arg(short, long)]
    check: bool,
}

fn main() -> Result<()> {
    let cli = Cli::parse();

    if cli.debug {
        println!("[DEBUG] Input: {:?}", cli.input);
        println!("[DEBUG] Output: {:?}", cli.output);
        println!("[DEBUG] Project: {:?}", cli.project);
    }

    // Read input file
    let source = std::fs::read_to_string(&cli.input)?;

    if cli.debug {
        println!("[DEBUG] Source length: {} bytes", source.len());
    }

    // Transpile Python to Rust
    let rust_code = transpile(&source)?;

    if cli.debug {
        println!("[DEBUG] Generated Rust code:");
        println!("{}", rust_code);
    }

    // Check mode
    if cli.check {
        println!("✅ Transpilation successful!");
        return Ok(());
    }

    // Project generation mode
    if let Some(project_name) = &cli.project {
        generate_project(project_name, &rust_code)?;
        println!("✅ Generated project: {}/", project_name);
        println!("   Run: cd {} && cargo build --release", project_name);
        return Ok(());
    }

    // Single file transpilation
    let output_path = cli.output.unwrap_or_else(|| {
        let mut p = cli.input.clone();
        p.set_extension("rs");
        p
    });

    std::fs::write(&output_path, &rust_code)?;
    println!("✅ Transpiled to: {:?}", output_path);

    Ok(())
}

/// Generate a complete Rust project
fn generate_project(name: &str, rust_code: &str) -> Result<()> {
    use std::fs;

    // Create project directory
    fs::create_dir_all(format!("{}/src", name))?;

    // Create Cargo.toml
    let cargo_toml = format!(
        r#"[package]
name = "{}"
version = "0.1.0"
edition = "2021"

[dependencies]
"#,
        name
    );
    fs::write(format!("{}/Cargo.toml", name), cargo_toml)?;

    // Create .gitignore
    let gitignore = "/target\n";
    fs::write(format!("{}/.gitignore", name), gitignore)?;

    // Create main.rs with transpiled code
    let main_rs = format!(
        r#"// Generated by Tsuchinoko - Python to Rust Transpiler
// Author: Tane Channel Technology

fn main() {{
    // Transpiled code:
{}
}}
"#,
        rust_code.lines().map(|l| format!("    {}", l)).collect::<Vec<_>>().join("\n")
    );
    fs::write(format!("{}/src/main.rs", name), main_rs)?;

    Ok(())
}
