//! PythonBridge - Self-contained module for Resident Python Worker
//! Generated by Tsuchinoko

use std::io::{BufRead, BufReader, Write};
use std::process::{Child, Command, Stdio};
use std::sync::atomic::{AtomicU64, Ordering};

/// Embedded Python worker code
const WORKER_CODE: &str = r#####"
"""
Tsuchinoko Python Worker
========================

常駐プロセス方式で Rust バイナリから呼び出される Python ワーカー。
stdin/stdout で NDJSON 通信を行い、任意の Python ライブラリを呼び出す。

このコードは Rust 側に文字列として埋め込まれ、
`python -u -c "<WORKER_CODE>"` で起動される。
"""

import sys
import json
import importlib
import traceback

# モジュールキャッシュ
_modules_cache = {}


def get_callable(target: str):
    """
    target 文字列から callable を解決する。
    例: "math.sqrt" -> math.sqrt
        "numpy.linalg.norm" -> numpy.linalg.norm
    """
    parts = target.split(".")
    if len(parts) < 2:
        raise ValueError(f"Invalid target: {target}")
    
    # 最短モジュール名から試行（例: "numpy" を先に試す）
    for i in range(1, len(parts)):
        module_name = ".".join(parts[:i])
        attr_path = parts[i:]
        
        # キャッシュまたは新規 import
        if module_name not in _modules_cache:
            try:
                _modules_cache[module_name] = importlib.import_module(module_name)
            except ImportError:
                continue
        
        # 属性チェーンを辿る
        obj = _modules_cache[module_name]
        try:
            for attr in attr_path:
                obj = getattr(obj, attr)
            return obj
        except AttributeError:
            continue
    
    raise ValueError(f"Cannot resolve target: {target}")


def handle_call(request: dict) -> dict:
    """call 操作を処理"""
    target = request.get("target")
    args = request.get("args", [])
    kwargs = request.get("kwargs", {})
    
    if not target:
        return {"ok": False, "error": "Missing 'target' field"}
    
    try:
        func = get_callable(target)
        result = func(*args, **kwargs)
        
        # JSON 化できるか確認
        try:
            json.dumps(result)
            return {"ok": True, "result": result}
        except (TypeError, ValueError):
            # JSON 化できない場合は文字列化
            # numpy 配列などは tolist() を試す
            if hasattr(result, "tolist"):
                return {"ok": True, "result": result.tolist()}
            elif hasattr(result, "to_dict"):
                return {"ok": True, "result": result.to_dict()}
            else:
                return {"ok": True, "result": str(result)}
    
    except Exception as e:
        return {
            "ok": False,
            "error": str(e),
            "error_type": type(e).__name__,
            "traceback": traceback.format_exc()
        }


def main():
    """メインループ: stdin から NDJSON を読み、処理して stdout へ返す"""
    for line in sys.stdin:
        line = line.strip()
        if not line:
            continue
        
        try:
            request = json.loads(line)
        except json.JSONDecodeError as e:
            response = {"id": None, "ok": False, "error": f"JSON parse error: {e}"}
            print(json.dumps(response), flush=True)
            continue
        
        req_id = request.get("id")
        op = request.get("op", "call")
        
        if op == "shutdown":
            response = {"id": req_id, "ok": True, "result": "shutdown"}
            print(json.dumps(response), flush=True)
            break
        elif op == "call":
            response = handle_call(request)
            response["id"] = req_id
        elif op == "ping":
            response = {"id": req_id, "ok": True, "result": "pong"}
        else:
            response = {"id": req_id, "ok": False, "error": f"Unknown op: {op}"}
        
        print(json.dumps(response), flush=True)


if __name__ == "__main__":
    main()
"#####;

/// Python worker communication manager
pub struct PythonBridge {
    process: Child,
    request_id: AtomicU64,
}

impl PythonBridge {
    /// Start Python worker
    pub fn new() -> Result<Self, String> {
        let process = Command::new("python")
            .args(["-u", "-c", WORKER_CODE])
            .stdin(Stdio::piped())
            .stdout(Stdio::piped())
            .stderr(Stdio::inherit())
            .spawn()
            .map_err(|e| format!("Failed to spawn Python worker: {}", e))?;

        Ok(Self {
            process,
            request_id: AtomicU64::new(1),
        })
    }

    fn call_raw(&mut self, target: &str, args: &[serde_json::Value]) -> Result<serde_json::Value, String> {
        let id = self.request_id.fetch_add(1, Ordering::SeqCst);
        
        let request = serde_json::json!({
            "id": id,
            "op": "call",
            "target": target,
            "args": args,
        });

        let stdin = self.process.stdin.as_mut()
            .ok_or("Failed to get stdin")?;
        writeln!(stdin, "{}", request.to_string())
            .map_err(|e| format!("Failed to write to stdin: {}", e))?;
        stdin.flush()
            .map_err(|e| format!("Failed to flush stdin: {}", e))?;

        let stdout = self.process.stdout.as_mut()
            .ok_or("Failed to get stdout")?;
        let mut reader = BufReader::new(stdout);
        let mut line = String::new();
        reader.read_line(&mut line)
            .map_err(|e| format!("Failed to read from stdout: {}", e))?;

        let response: serde_json::Value = serde_json::from_str(&line)
            .map_err(|e| format!("Failed to parse response: {}", e))?;

        if response["ok"].as_bool() == Some(true) {
            Ok(response["result"].clone())
        } else {
            Err(format!("Python error: {}", response["error"]))
        }
    }

    pub fn call_i64(&mut self, target: &str, args: &[serde_json::Value]) -> Result<i64, String> {
        let result = self.call_raw(target, args)?;
        result.as_i64().ok_or_else(|| format!("Expected i64, got: {}", result))
    }

    pub fn call_f64(&mut self, target: &str, args: &[serde_json::Value]) -> Result<f64, String> {
        let result = self.call_raw(target, args)?;
        result.as_f64().ok_or_else(|| format!("Expected f64, got: {}", result))
    }

    pub fn call_string(&mut self, target: &str, args: &[serde_json::Value]) -> Result<String, String> {
        let result = self.call_raw(target, args)?;
        result.as_str().map(|s| s.to_string()).ok_or_else(|| format!("Expected string, got: {}", result))
    }

    pub fn call_vec_i64(&mut self, target: &str, args: &[serde_json::Value]) -> Result<Vec<i64>, String> {
        let result = self.call_raw(target, args)?;
        result.as_array()
            .ok_or_else(|| format!("Expected array, got: {}", result))?
            .iter()
            .map(|v| v.as_i64().ok_or_else(|| format!("Expected i64 in array, got: {}", v)))
            .collect()
    }

    pub fn call_vec_f64(&mut self, target: &str, args: &[serde_json::Value]) -> Result<Vec<f64>, String> {
        let result = self.call_raw(target, args)?;
        result.as_array()
            .ok_or_else(|| format!("Expected array, got: {}", result))?
            .iter()
            .map(|v| v.as_f64().ok_or_else(|| format!("Expected f64 in array, got: {}", v)))
            .collect()
    }

    pub fn call_json(&mut self, target: &str, args: &[serde_json::Value]) -> Result<serde_json::Value, String> {
        self.call_raw(target, args)
    }

    pub fn shutdown(&mut self) -> Result<(), String> {
        let id = self.request_id.fetch_add(1, Ordering::SeqCst);
        let request = serde_json::json!({
            "id": id,
            "op": "shutdown",
        });

        if let Some(stdin) = self.process.stdin.as_mut() {
            let _ = writeln!(stdin, "{}", request.to_string());
            let _ = stdin.flush();
        }

        self.process.wait().map_err(|e| format!("Failed to wait for worker: {}", e))?;
        Ok(())
    }
}

impl Drop for PythonBridge {
    fn drop(&mut self) {
        let _ = self.shutdown();
    }
}
