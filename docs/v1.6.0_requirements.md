# Tsuchinoko v1.6.0 要件定義書

> **著者**: Tane Channel Technology  
> **バージョン**: v1.6.0  
> **作成日**: 2026-01-08  
> **最終更新**: 2026-01-09

---

## 0. 設計理念

### 0.1 基本原則

1. **「動かなければ意味がない」** - 最優先原則
2. **「構造化できるものは構造化する」** - 可能な範囲で

### 0.2 言語哲学

- **Python**: 処理を記述する言語（実行時の振る舞い）
- **Rust**: 構造を記述する言語（コンパイル時に決まる構造: trait、コンポジション、所有権）

**Tsuchinoko の役割**: Python の「処理」を Rust の「構造」に変換する

### 0.3 設計理念 (README より)

- **人間が読めるロジックの維持**: 生成されたRustコードは可読性が高く保守可能
- **命令型Pythonから構造的Rustへの変換**: 制御フローを等価な構造にマッピング
- **所有権よりも借用を優先**: 可能な限り参照 (`&[T]`, `&str`) を使用

---

## 1. 目的

- 実用的な Python コードのトランスパイル成功率を向上
- OOP (継承・プロパティ) の完成度向上
- リソース管理パターン (`with` 文) のサポート

**目標カバレッジ**: 65% → 75%

---

## 2. スコープ

### 2.1 対象機能 - MUST (Tier 1: 超高頻度)

| ID | 機能 | 構造化度 |
|----|------|----------|
| FT-001 | `with` 文 | ✅ 構造的 |
| FT-002 | クラス継承 (単一) | ✅ 構造的 |
| FT-003 | `@property` | ✅ 構造的 |

### 2.2 対象機能 - SHOULD (Tier 2: 高頻度)

| ID | 機能 | 構造化度 |
|----|------|----------|
| FT-004 | セット内包表記 | ✅ 構造的 |
| FT-005 | `isinstance()` | ⚠️ 動的 (enum で対応) |
| FT-006 | `**kwargs` | ⚠️ 動的 (HashMap で対応) |
| FT-007 | 連鎖比較 | ✅ 構造的 |
| FT-008 | PyO3 タプルアンパッキング | ✅ 構造的 |

### 2.3 バグ修正

| ID | 問題 | 修正内容 |
|----|------|----------|
| FT-009 | IndexAssign 二重キャスト | エミッタの冗長な `as usize` 削除 |

### 2.4 対象外

| 機能 | 理由 |
|------|------|
| 多重継承 | 複雑性が高い、v1.7.0 以降で検討 |
| `async/await` | 大規模変更、v1.7.0 で対応 |
| `yield`/Generator | 大規模変更、v1.7.0 で対応 |

---

## 3. 変換仕様

### 3.1 FT-001: `with` 文 → スコープ + Drop

**設計思想**: リソースの所有権をスコープで構造化

**入力 - Python**:
```python
with open("file.txt", "r") as f:
    content = f.read()
# f は自動的にクローズ
```

**出力 - Rust**:
```rust
{
    let f = File::open("file.txt")?;
    let content = std::io::read_to_string(&f)?;
}  // スコープ終了 = Drop = リソース解放
```

**変換ルール**:
- `with expr as name:` → `{ let name = expr; ... }`
- `__enter__` → 変数への束縛
- `__exit__` → スコープ終了時の `Drop`

**標準関数マッピング**:

| Python | Rust |
|--------|------|
| `open(path, "r")` | `File::open(path)?` |
| `open(path, "w")` | `File::create(path)?` |
| `Lock()` | `Mutex::lock()` |

**制約**:
- カスタムコンテキストマネージャは未対応
- 標準的なファイル/ロックパターンを優先

---

### 3.2 FT-002: クラス継承 → コンポジション (Has-A)

**設計思想**: 継承を「構造としての包含」で表現

> [!IMPORTANT]
> Rust の trait ではなくコンポジションを採用。
> 理由: Python の継承はフィールドも含めて継承するが、trait はメソッドのみ。

**入力 - Python**:
```python
class Animal:
    def __init__(self, name: str) -> None:
        self.name = name
    
    def speak(self) -> str:
        return "..."

class Dog(Animal):
    def __init__(self, name: str, breed: str) -> None:
        super().__init__(name)
        self.breed = breed
    
    def speak(self) -> str:
        return f"{self.name} says Woof!"
```

**出力 - Rust**:
```rust
#[derive(Clone)]
struct Animal {
    name: String,
}

impl Animal {
    fn new(name: String) -> Self {
        Self { name }
    }
    
    fn speak(&self) -> String {
        "...".to_string()
    }
}

#[derive(Clone)]
struct Dog {
    base: Animal,  // コンポジション: 基底クラスを包含
    breed: String,
}

impl Dog {
    fn new(name: String, breed: String) -> Self {
        Self {
            base: Animal::new(name),
            breed,
        }
    }
    
    // メソッドオーバーライド
    fn speak(&self) -> String {
        format!("{} says Woof!", self.base.name)
    }
    
    // 基底メソッドへの委譲 (必要に応じて生成)
    fn name(&self) -> &str {
        &self.base.name
    }
}
```

**変換ルール**:
- `class Child(Parent):` → `struct Child { base: Parent, ... }`
- `super().__init__(...)` → `base: Parent::new(...)`
- `super().method()` → `self.base.method()`
- オーバーライドメソッド → 同名メソッドを子に定義
- 非オーバーライドメソッド → 委譲メソッドを生成

**super() メソッド呼び出し例**:

```python
# Python
class Dog(Animal):
    def speak(self) -> str:
        parent_say = super().speak()
        return parent_say + " Woof!"
```

```rust
// Rust
fn speak(&self) -> String {
    let parent_say = self.base.speak();
    format!("{} Woof!", parent_say)
}
```

---

### 3.3 FT-003: `@property` → getter/setter メソッド

**設計思想**: 属性アクセスをメソッドとして構造化

**入力 - Python**:
```python
class Circle:
    def __init__(self, radius: float) -> None:
        self._radius = radius
    
    @property
    def radius(self) -> float:
        return self._radius
    
    @radius.setter
    def radius(self, value: float) -> None:
        if value < 0:
            raise ValueError("Radius must be positive")
        self._radius = value
```

**出力 - Rust**:
```rust
#[derive(Clone)]
struct Circle {
    _radius: f64,
}

impl Circle {
    fn new(radius: f64) -> Self {
        Self { _radius: radius }
    }
    
    fn radius(&self) -> f64 {
        self._radius
    }
    
    fn set_radius(&mut self, value: f64) -> Result<(), TsuchinokoError> {
        if value < 0.0 {
            return Err(TsuchinokoError::new("ValueError", "Radius must be positive", None));
        }
        self._radius = value;
        Ok(())
    }
}
```

**変換ルール**:
- `@property` → `fn name(&self) -> T`
- `@name.setter` → `fn set_name(&mut self, value: T)`
- setter 内で例外発生 → `Result` を返す

**呼び出し側の変換**:

```python
# Python
circle.radius = 5.0  # setter 呼び出し
```

```rust
// Rust
circle.set_radius(5.0)?;  // メソッド呼び出しに変換
```

**Semantic 処理**:
1. `FieldAssign` を検出
2. ターゲットが `@property` + setter 定義済みなら `MethodCall` に変換
3. setter が例外を発生させる場合は `?` 付き

---

### 3.4 FT-004: セット内包表記 → HashSet

**設計思想**: イテレーション構造を HashSet 生成に変換

**入力 - Python**:
```python
numbers = [1, 2, 2, 3, 3, 3]
unique = {x * 2 for x in numbers if x > 1}
```

**出力 - Rust**:
```rust
let numbers: Vec<i64> = vec![1, 2, 2, 3, 3, 3];
let unique: HashSet<i64> = numbers
    .iter()
    .filter(|&x| *x > 1)
    .map(|x| x * 2)
    .collect();
```

**変換ルール**:
- 既存のリスト内包表記ロジックを拡張
- 結果型を `HashSet<T>` に変更

---

### 3.5 FT-005: `isinstance()` → enum + match

**設計思想**: 動的型チェックを enum バリアントで表現

> [!NOTE]
> これは本質的に動的な機能。enum で構造化しつつ、動的な振る舞いを保持。

**入力 - Python**:
```python
def process(value):
    if isinstance(value, str):
        return value.upper()
    elif isinstance(value, int):
        return value * 2
    else:
        return value
```

**出力 - Rust**:
```rust
#[derive(Clone)]
enum DynamicValue {
    Int(i64),
    Str(String),
    Float(f64),
    Bool(bool),
    None,
}

fn process(value: DynamicValue) -> DynamicValue {
    match value {
        DynamicValue::Str(s) => DynamicValue::Str(s.to_uppercase()),
        DynamicValue::Int(n) => DynamicValue::Int(n * 2),
        other => other,
    }
}
```

**変換ルール**:
- `isinstance()` でチェックされる型を収集
- 関数引数を `DynamicValue` enum に変換
- `isinstance(x, T)` → `match x { T(v) => ... }`

**呼び出し側の変換**:

```python
# Python
result = process(42)
```

```rust
// Rust
let result = process(DynamicValue::Int(42));
```

**Semantic 処理**:
1. 関数定義時に `isinstance` 使用を検出 → 引数型を `DynamicValue` に変換
2. 呼び出し側で引数をラップする `IrExpr::DynamicValue` を生成

**制約**:
- チェックされる型が静的に特定できる場合のみ対応
- クラス型の `isinstance` は継承構造との整合性が必要

---

### 3.6 FT-006: `**kwargs` → HashMap

**設計思想**: 動的なキーワード引数は動的なまま受け入れる

> [!NOTE]
> これは本質的に動的な機能。「動かなければ意味がない」原則を優先。

**入力 - Python**:
```python
def greet(name: str, **kwargs):
    greeting = kwargs.get("greeting", "Hello")
    uppercase = kwargs.get("uppercase", False)
    result = f"{greeting}, {name}!"
    if uppercase:
        result = result.upper()
    return result
```

**出力 - Rust**:
```rust
use std::collections::HashMap;
use serde_json::Value;

fn greet(name: &str, kwargs: HashMap<String, Value>) -> String {
    let greeting = kwargs.get("greeting")
        .and_then(|v| v.as_str())
        .unwrap_or("Hello");
    let uppercase = kwargs.get("uppercase")
        .and_then(|v| v.as_bool())
        .unwrap_or(false);
    
    let result = format!("{}, {}!", greeting, name);
    if uppercase {
        result.to_uppercase()
    } else {
        result
    }
}
```

**変換ルール**:
- `**kwargs` → `HashMap<String, serde_json::Value>`
- `kwargs.get("key")` → `kwargs.get("key").and_then(|v| v.as_T())`
- `kwargs.get("key", default)` → `.unwrap_or(default)`

---

### 3.7 FT-007: 連鎖比較 → let 束縛 + &&

**設計思想**: 中間値を構造として束縛

**入力 - Python**:
```python
def in_range(x):
    return 0 < x < 10
```

**出力 - Rust**:
```rust
fn in_range(x: i64) -> bool {
    0 < x && x < 10
}

// 副作用がある場合
fn check(get_value: impl Fn() -> i64) -> bool {
    let _mid = get_value();  // 1回だけ評価
    0 < _mid && _mid < 10
}
```

**変換ルール**:
- `a op1 b op2 c` → `a op1 b && b op2 c`
- 中間値が関数呼び出しの場合 → `let` で束縛して1回のみ評価

---

### 3.8 FT-008: PyO3 タプルアンパッキング

**設計思想**: 外部呼び出し結果のタプル展開を構造化

> [!NOTE]
> PyO3 経由の戻り値が Python タプルの場合、`serde_json::Value` の配列として取得し、
> 各要素を個別の変数に展開する。

**入力 - Python**:
```python
import cv2

camera = cv2.VideoCapture(0)
ret, frame = camera.read()  # タプルを2変数に展開
```

**現在の問題**:
```rust
// ❌ 現在の生成コード (エラー)
let (ret, frame) = {
    py_bridge.call_json_method::<serde_json::Value>(camera.clone(), "read")
};  // Value を (_, _) に代入できない
```

**出力 - Rust (修正後)**:
```rust
// ✅ 正しい変換
let _tuple_result = py_bridge.call_json_method::<serde_json::Value>(
    camera.clone(), "read", &[]
)?;
let ret = _tuple_result[0].clone();
let frame = _tuple_result[1].clone();
```

**変換ルール**:
- `a, b = expr` で `expr` が PyO3 呼び出しの場合:
  1. 結果を一時変数 `_tuple_result` に格納
  2. `a = _tuple_result[0].clone()`
  3. `b = _tuple_result[1].clone()`
- 3つ以上の変数にも対応: `a, b, c = expr` → `[0]`, `[1]`, `[2]`

**型推論による自動変換**:

後続の使用パターンを静的解析して型を推論し、適切な変換を生成:

```python
# Python
ret, frame = camera.read()
if ret:  # bool として使用
    process(frame)
```

```rust
// Rust
let _tuple = py_bridge.call_json_method::<Value>(...)?;
let ret = _tuple[0].as_bool().unwrap_or(false);  // 自動変換
let frame = _tuple[1].clone();
if ret {
    // ...
}
```

**Semantic 処理**:
1. 後続の使用パターンを解析
2. `if var:` → `var.as_bool().unwrap_or(false)`
3. 型が特定できない場合は `serde_json::Value` のまま

**制約**:
- PyO3 戻り値が実際にタプル/リストであることが前提

---

### 3.9 FT-009: IndexAssign 二重キャスト修正

**問題**: インデックス代入で `as usize` が二重に生成される

**現在の出力**:
```rust
// ❌ 冗長なキャスト
sorted_list[(j as usize) as usize] = sorted_list[((j + 1i64) as usize)];
```

**原因**:
1. セマンティック: `IrExpr::Cast { ty: "usize" }` を生成
2. エミッタ: `IndexAssign` 出力時に再度 `as usize` を追加

**修正後の出力**:
```rust
// ✅ 正しい出力
sorted_list[(j as usize)] = sorted_list[((j + 1i64) as usize)];
```

**修正内容**:
- `src/emitter/mod.rs` 371行目: `[{} as usize]` → `[{}]`
- セマンティックで既に `Cast { ty: "usize" }` を生成済みのため、エミッタでの追加は不要

---

## 4. 技術設計

### 4.1 AST 変更

```rust
// with 文
Stmt::With {
    items: Vec<(Expr, Option<String>)>,  // (context_expr, as_name)
    body: Vec<Stmt>,
}

// クラス継承
Stmt::ClassDef {
    name: String,
    bases: Vec<String>,  // 追加: 基底クラス名
    fields: Vec<Field>,
    methods: Vec<MethodDef>,
}

// デコレータ
MethodDef {
    decorators: Vec<Decorator>,  // 追加
    // ...
}

enum Decorator {
    Property,
    PropertySetter(String),
    StaticMethod,
    Other(String),
}

// 連鎖比較
Expr::ChainedCompare {
    operands: Vec<Expr>,
    operators: Vec<CmpOp>,
}
```

### 4.2 IR 変更

```rust
// with 文
IrNode::WithBlock {
    context: Box<IrExpr>,
    var_name: Option<String>,
    body: Vec<IrNode>,
}

// 動的型 enum
IrExpr::DynamicValue {
    variant: String,
    value: Box<IrExpr>,
}

// isinstance チェック
IrExpr::InstanceCheck {
    target: Box<IrExpr>,
    type_name: String,
}
```

---

## 5. 実装フェーズ

| Phase | 作業内容 | 優先度 | 見積もり |
|-------|----------|--------|----------|
| 1 | IndexAssign 二重キャスト修正 (FT-009) | BUG | 極小 |
| 2 | 連鎖比較 (FT-007) | SHOULD | 小 |
| 3 | セット内包表記 (FT-004) | SHOULD | 小 |
| 4 | PyO3 タプルアンパッキング (FT-008) | SHOULD | 小〜中 |
| 5 | `@property` (FT-003) | MUST | 中 |
| 6 | `**kwargs` (FT-006) | SHOULD | 中 |
| 7 | `with` 文 (FT-001) | MUST | 中 |
| 8 | クラス継承 (FT-002) | MUST | 大 |
| 9 | `isinstance()` (FT-005) | SHOULD | 中〜大 |

---

## 6. 成功基準

| # | 基準 | 検証方法 |
|---|------|----------|
| 1 | `with` が RAII スコープで変換される | 生成コード確認 |
| 2 | 継承がコンポジションで動作 | システムテスト |
| 3 | `@property` メソッドが正しく生成 | システムテスト |
| 4 | セット内包表記が `HashSet` に変換 | ユニットテスト |
| 5 | 連鎖比較が `&&` で展開される | ユニットテスト |
| 6 | `**kwargs` が HashMap で動作 | システムテスト |
| 7 | `isinstance` が enum match で動作 | システムテスト |
| 8 | PyO3 タプル戻り値が正しく展開される | OpenCV テスト |
| 9 | IndexAssign で二重キャストが解消 | bubbleSort テスト |
| 10 | リグレッション 74件 + 新規 全パス | 自動テスト |

---

## 7. リスク

| リスク | 対策 |
|--------|------|
| 継承のコンポジション変換の複雑化 | 単一継承のみに限定 |
| `isinstance` の型特定が困難 | 静的解析可能な範囲に限定 |
| 既存機能との互換性 | 各フェーズでリグレッションテスト |

---

## 8. 今後の展望 (v1.7.0 候補)

- `async/await` 対応
- `yield` / Generator
- 多重継承
- 抽象基底クラス (`abc`)
- `@classmethod`
