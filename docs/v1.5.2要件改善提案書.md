# 0. 用語の厳密定義（v1.5.2の前提）

## 0.1 Result統一 とは何か（＝言語仕様）

**定義**：
Tsuchinokoが変換する“Python例外（raise / raise from / try/except/else/finally）”を、生成Rustコード上で **`Result<T, TsuchinokoError>`** によって表現すること。

### 具体的に何が変わる？

1. **例外が起きうる関数は `Result` を返す**

* Pythonで例外が飛ぶ可能性がある処理を含む関数は、Rust側で `fn f(...) -> Result<T, TsuchinokoError>` になる。

2. **例外の発生は `Err(TsuchinokoError {..})`**

* `raise ValueError("x")` → `return Err(TsuchinokoError::new("ValueError","x", None))`

3. **例外の伝播は `?`**

* Pythonで例外が上に飛ぶのと同じ意味を、Rustの `?` で実現する。

4. **try/except は `match`（分岐）**

* `try: ... except X as e: ... else: ... finally: ...` を
  `match` と `Ok/Err` の分岐として再現する。

5. **raise from は cause を保持**

* `raise A("msg") from e` → `Err(TsuchinokoError::new("A","msg", Some(e)))`

---

## 0.2 案1 とは何か（＝純Rust panic を例外に“変換”する保険）

**定義**：
生成されたRustコード（およびTsuchinokoランタイム）が **想定外にpanicしたとき**、`std::panic::catch_unwind` で捕捉し、**`TsuchinokoError(kind="InternalError" または "Panic")` に変換して返す**方式。

### 何を捕まえる？

* `unwrap()` 失敗
* `index out of bounds`
* `todo!()/unimplemented!()`
* `assert!()` 失敗
* Tsuchinoko側バグでのpanic

### 何を捕まえない？

* **abort / segfault / UB**（プロセス死亡）
  → catch_unwindでは無理。これは別枠。

### 具体的な生成イメージ

Python:

```python
try:
    x = risky()
except Exception:
    handle()
```

Rust（案1を有効化した場合の概念）:

```rust
let r = std::panic::catch_unwind(|| {
    risky()?;                 // Result統一の世界
    Ok(())
});

match r {
    Ok(ok_or_err) => ok_or_err, // Ok(Result)
    Err(payload) => Err(TsuchinokoError::internal(payload)),
}
```

要するに：

* **“panicをErrに落とす”**のが案1。

---

## 0.3 案2 とは何か（＝外部境界の失敗をpanicにしない規約）

**定義**：
PyO3または常駐プロセス（py_bridge）などの“外部呼び出し境界”で発生する失敗を、**panic（unwrap）にせず**、必ず **`Result<_, TsuchinokoError>`** として返す方式。

### 何を対象にする？

* **PyO3**：`PyErr` を捕捉して TsuchinokoError に変換
* **常駐プロセス**：RPC応答のエラー／例外情報を TsuchinokoError に変換
* **Python例外**：ValueError/TypeError/ImportError… を “原因情報付き” で保持

### 何が目的？

* 「Python側が例外を出しただけ」なのに、Rust側が `unwrap()` して **panicで死ぬ**のを防ぐ
* `raise from` の **cause** を欠損させない

### 具体的な実装規約（例）

* ❌ `py.call(...).unwrap()` は禁止
* ✅ `py.call(...) -> Result<T, TsuchinokoError>` を返す
* ✅ `PyErr` は `kind/message/（可能なら）python traceback/行番号` に変換して保持

---

# 1. 守備範囲マトリクス（定義反映版）

| 種類                      | 例                     | Result統一（仕様） | 案2（外部境界Result化） | 案1（panic回収）          |
| ----------------------- | --------------------- | ------------ | --------------- | -------------------- |
| Python例外                | ValueError, TypeError | ◎（Err化して伝播）  | ◎（PyErr→Err）    | △（例外がpanic化した後なら）    |
| raise / raise from      | cause連鎖               | ◎（cause保持）   | ◎（cause欠損防止）    | ×                    |
| try/except/else/finally | 制御構造                  | ◎（matchで再現）  | △               | △（try内panicをErr化）    |
| 外部呼び出し失敗                | import失敗/属性なし         | ◎（例外として扱う）   | ◎（panic化を防止）    | △（unwrap等でpanicした場合） |
| 生成物のバグpanic             | unwrap/OOB/todo       | ×（仕様外）       | ×               | ◎（InternalError化）    |
| abort/segfault          | プロセス死亡                | ×            | ×               | ×                    |

---

# 2. v1.5.2 要件改善提案書（定義済み前提で書き直し）

## 2.1 改善の狙い（レビュワー懸念への回答）

* **Result伝播の範囲**：Result統一の定義として「呼び出し関係に従って伝播」が明記される
* **catch_unwindとの整合**：案1は“仕様”ではなく“保険”として位置づける（混線を防止）
* **外部ライブラリ統合**：案2により、PyO3/常駐のエラーはTsus


了解。ここからは「そのまま要件書に貼れる」レベルで、**用語定義→守備範囲表→要件改善提案**の順で出すね。
（前回の文章は途中で切れてたので、今回は最後まで完結させる）

---

# Tsuchinoko v1.5.2 要件改善提案書（改訂版）

## 0. 用語の厳密定義（この章を要件書の冒頭に追加）

### 0.1 「Result 型統一」とは（言語仕様）

**定義**：
Python の例外機構（`raise / raise from / try-except-else-finally`）を、生成Rustコード上で **`Result<T, TsuchinokoError>`** により表現すること。

**具体的仕様**

1. **例外が発生し得る関数は `Result` を返す**

   * Rust: `fn f(...) -> Result<T, TsuchinokoError>`
2. **raise は `Err(TsuchinokoError)` を返す**

   * `raise ValueError("x")` → `return Err(TsuchinokoError::new("ValueError", "x", None))`
3. **例外の伝播は `?` を用いる**

   * `g()` が `Result` のとき、`g()?;` で上位へ伝播する
4. **try/except/else/finally は `match` と `Ok/Err` 分岐で再現する**
5. **raise from は cause を保持してチェーン化する**

   * `raise A("m") from e` → `Err(TsuchinokoError::new("A","m", Some(e)))`

---

### 0.2 「案1（catch_unwind）」とは（保険・診断）

**定義**：
生成Rustコード（またはランタイム）が **想定外に panic** した場合に、`std::panic::catch_unwind` で捕捉し、**`TsuchinokoError(kind="InternalError" / "Panic")` に変換して返す**方式。

**対象（捕捉するもの）**

* `unwrap()` 失敗
* `index out of bounds`
* `todo!()/unimplemented!()`
* `assert!()` 失敗
* Tsuchinokoの変換・ランタイムバグによる panic

**対象外（捕捉できないもの）**

* `abort()`、Segfault、UB（プロセス死亡）
  → catch_unwindでは救えないため、これは「異常終了」領域として別扱い

**目的**

* “即死”ではなく、**診断可能な例外（InternalError）として回収**し、エラーメッセージを改善する

---

### 0.3 「案2（外部境界Result化）」とは（実装規約）

**定義**：
PyO3・常駐プロセス（py_bridge）などの **外部呼び出し境界**で発生した失敗を、panicにせず、必ず **`Result<_, TsuchinokoError>`** として返す方式。

**具体的規約**

* ❌ `unwrap()` で落とさない（外部境界では禁止）
* ✅ 例外・失敗は `Err(TsuchinokoError)` へ変換して返す
* ✅ Python例外の情報（種類・メッセージ・可能なら行番号/トレース）を欠損させない
* ✅ `raise from` の `cause` として利用可能な形で保持する

---

## 1. 守備範囲マトリクス（要件書に貼る表）

| 種類                      | 例                      | Result統一（仕様） | 案2（外部境界Result化） | 案1（panic回収） |
| ----------------------- | ---------------------- | -----------: | --------------: | ----------: |
| Python例外                | ValueError, TypeError  |            ◎ |               ◎ |           △ |
| raise / raise from      | 例外チェーン                 |            ◎ |               ◎ |           × |
| try/except/else/finally | 制御構造                   |            ◎ |               △ |           △ |
| 外部呼び出し失敗                | import失敗/属性なし/型不一致     |            ◎ |               ◎ |           △ |
| 生成物のバグpanic             | unwrap/OOB/todo/assert |            × |               × |           ◎ |
| abort/segfault/UB       | プロセス死亡                 |            × |               × |           × |

※ ◎=主戦場 / △=副次的に効く / ×=対象外

---

## 2. 改善提案の結論（レビュワー懸念への回答）

### 2.1 「Result伝播の範囲」問題への回答（仕様として明文化）

**仕様を以下で固定する：**

* **例外が“try/exceptで捕捉されない限り”**、`Result` は **呼び出し元へ伝播**する
* したがって **コールグラフに沿って `Result` は必要に応じて昇格**する
* ただし「常に全関数をResultにする」のではなく、**解析結果に基づく最小伝播**とする

> 要件文案：
> 「try/exceptで捕捉されない例外は、呼び出し関係に従って上位関数へ伝播する。これを実現するため、必要な範囲の関数は `Result<T, TsuchinokoError>` に昇格する。」

---

### 2.2 「catch_unwindとの整合」問題への回答（役割分離）

* `try/except` の本体は **Result統一（言語仕様）**
* `catch_unwind`（案1）は **言語仕様ではなく保険・診断機能**
  → これを明確に分離して記述することで、「根本的に異なるアーキテクチャになる」懸念を解消

> 要件文案：
> 「案1（catch_unwind）は、Tsuchinoko生成物の想定外panicをInternalErrorへ変換する診断機能であり、Python例外の意味論変換（Result統一）とは独立に実装する。」

---

### 2.3 「外部ライブラリ呼び出し統合」問題への回答（案2の仕様化）

* PyO3/常駐プロセスで発生する失敗は **まず案2で TsuchinokoError に正規化**
* その後、Result統一の枠組みで `try/except` と `raise from` に接続する
* `abort/segfault` は **救えない領域**として明示し、常駐プロセス方式では「worker死亡」として例外化する（可能なら）

> 要件文案：
> 「外部境界（PyO3/常駐プロセス）での失敗は panic 化せず `Err(TsuchinokoError)` として返す。プロセス死亡（abort/segfault）は対象外とし、常駐プロセス方式では worker死亡を検知して `WorkerCrashed` として例外化する。」

---

## 3. 追加・修正すべき要件（v1.5.2のMUST/SHOULD）

### 3.1 MUST（v1.5.2で必須）

1. **Result統一（言語仕様）を実装**
2. **案2（外部境界Result化）を実装**
3. `raise from` の **cause保持**を保証
4. `try/except/else` の意味論を `match` で再現

### 3.2 SHOULD（v1.5.2または次点で推奨）

1. **案1（catch_unwind）を“診断モード”として実装**

   * panic payload を内部エラーに保持
   * “Tsuchinoko内部エラー”として明確に表示
2. エラー出力に Python行番号・修正案を付与（現要件の継続）

---

## 4. 成功基準（レビューで検証可能な形に）

* `raise A from B` が cause付きで生成される
* `try/except/else` の else が「例外が無い場合のみ」実行される
* 外部呼び出し失敗が panic ではなく TsuchinokoError で返る（案2）
* （診断モードON時）生成物のpanicが InternalError として回収される（案1）
* 既存リグレッション + 新規テストが全パス

### 4.1 検証用テストケース

**Test 1: raise from**

```python
def test_raise_from():
    try:
        int("abc")
    except ValueError as e:
        raise RuntimeError("conversion failed") from e
```

生成されるRust:

```rust
fn test_raise_from() -> Result<(), TsuchinokoError> {
    match "abc".parse::<i64>() {
        Ok(v) => Ok(()),
        Err(original) => {
            Err(TsuchinokoError::new(
                "RuntimeError",
                "conversion failed",
                Some(TsuchinokoError::new("ValueError", &original.to_string(), None)),
            ))
        }
    }
}
```

**Test 2: try/except/else**

```python
def test_else():
    try:
        result = safe_operation()
    except ValueError:
        return -1
    else:
        return result * 2  # 例外が発生しなかった場合のみ実行
```

**Test 3: Result伝播**

```python
def outer():
    inner()  # inner が例外を投げる可能性

def inner():
    raise ValueError("error")
```

生成されるRust:

```rust
fn outer() -> Result<(), TsuchinokoError> {
    inner()?;  // ? で伝播
    Ok(())
}

fn inner() -> Result<(), TsuchinokoError> {
    Err(TsuchinokoError::new("ValueError", "error", None))
}
```

---

## 5. 実装フロー（Phase分け）

| Phase | 作業内容 | 優先度 |
|-------|----------|--------|
| **1** | `TsuchinokoError` 型定義 (`src/runtime/error.rs`) | MUST |
| **2** | AST 拡張 (`cause`, `else_body` フィールド追加) | MUST |
| **3** | 例外発生関数の Result 化 + 伝播解析 | MUST |
| **4** | `try/except/else` を `match` に変換 | MUST |
| **5** | 案2: 外部境界 (PyO3/py_bridge) Result 化 | MUST |
| **6** | 案1: `catch_unwind` 診断モード | SHOULD |

---

## 6. 設計理由（Why Result?）

### 6.1 async/await 対応への布石

将来の async/await 対応を見据え、panic ベースではなく Result 型を採用する。

* `panic!` と async ランタイム (tokio, async-std) は相性が悪い
* `Result<T, E>` と `?` 演算子は async/await と自然に組み合わせられる
* Python の `async def` / `await` を将来変換するための前準備

### 6.2 Rust らしいエラー処理

* 関数シグネチャにエラー可能性が明示される
* コンパイル時に未処理のエラーが検出される
* ライブラリコードとの統合が容易

---

## 7. レビュワーへの返答（短文テンプレ）

> ご指摘の通り、Result伝播範囲とcatch_unwindの位置づけが曖昧でした。
> v1.5.2では「Result統一＝Python例外の意味論（仕様）」「案2＝外部境界での失敗の正規化（規約）」「案1＝想定外panicの診断回収（保険）」と役割を分離して明記します。
> これにより、try/except変換のアーキテクチャと、生成物品質保証の議論を分離しつつ統合可能になります。
> 
> また、将来の async/await 対応を見据え、panic ベースではなく Result 型を採用する設計理由を追記しました。


# 備忘（要件レビュー指摘事項）
技術的な懸念点:

懸念	詳細
Result 伝播の範囲	「例外発生関数は Result を返す」とあるが、その関数を呼ぶ関数も Result を返す必要があるのか？コールグラフ全体に伝播する？
既存の catch_unwind との整合	現在 try-except は std::panic::catch_unwind で実装。Result 方式に変えると根本的に異なるアーキテクチャになる
外部ライブラリ呼び出し	py_bridge 経由の Python 呼び出しでエラーが発生した場合、TsuchinokoError とどう統合するのか
要件の曖昧さ:

要件定義書の「例外が発生し得る関数は Result<T, E> を返す」について:

明示的な raise を含む関数だけ？
それとも、raise を含む関数を呼ぶ関数も？（伝播）
try-except で catch している場合は Result 不要？
これらが明確でないと、実装方針が大きく変わります。

提案:

Phase 1/2 を先に実装しながら、Phase 3 のスコープを以下から選んでもらえますか？

オプション	内容	複雑度
A	raise を含む関数のみ Result 化（伝播なし）	低
B	呼び出し元にも Result 伝播（完全版）	高
C	try-except は catch_unwind のまま、raise のみ Result 化	中
