# import 対応の要件定義

---

## 1. 目的

* Tsuchinokoが Rustへ形式変換したプログラムにおいて、**Rust側で直接実装できないPythonライブラリ呼び出し（import依存）**を、**別プロセスのPython（常駐ワーカー）**へ委譲することで実行可能にする。
* PyO3等の埋め込み方式の互換性問題を回避し、**CPythonが動く限り動く**実行互換性を確保する。
* 変換結果を「人間が読める」レベルで保つ（生成Rustが過剰に汚れない）。

---

## 2. 方式の概要（B案）

* 変換後Rustバイナリ起動時に、**Pythonワーカープロセスを1回だけ起動**し、終了まで常駐させる。
* Rust⇄Pythonは **stdin/stdoutで1行JSON（NDJSON）** を送受信する。
* Pythonワーカーは受け取った命令に従い、必要なモジュールを **遅延import + キャッシュ**し、関数呼び出しを実行して結果を返す。

---

## 3. 変換後Rustコードに追加される構成要素（生成物）

### 3.1 PythonBridge（ランタイム部品）

変換後Rustに自動注入される“ブリッジ層”として以下を含む：

* **ワーカー起動・保持**

  * `python` 実行ファイルパス決定（設定で指定可能）
  * 子プロセス起動（`-u` 必須）
  * stdinに書き込み、stdoutから行単位で応答読み取り
* **RPC送受信**

  * リクエストJSON生成、送信、レスポンスJSON解析
  * `id` による対応付け（単発同期呼び出しでは必須ではないが入れておく）
* **エラーハンドリング**

  * Python側例外を `ok:false` として受け取る
  * ワーカー死亡/パイプ破断時の検知
  * リトライ方針（1回再起動して再送、など）
* **終了処理**

  * Rust終了時に `shutdown` を送る（任意）
  * 送らずにkill/Dropでもよいが、ゾンビ回避のため設計

### 3.2 埋め込みPythonワーカーコード（文字列）

* 生成Rustの中に、**ワーカーPythonプログラム全体を文字列として埋め込む**。
* Rustは `python -u -c "<WORKER_CODE>"` で起動する。

  * *外部 `.py` を生成しない*（要件）

---

## 4. Pythonワーカーの仕様（要件の核）

### 4.1 入出力（プロトコル）

* 入力：stdinから **1行=1JSON**（UTF-8）
* 出力：stdoutへ **1行=1JSON**（UTF-8）
* ログ：stderr（stdoutに混ぜない）

#### リクエストJSON（最低限）

* `id`: int（連番）
* `op`: str（操作名）

  * `"call"`: 関数呼び出し
  * `"shutdown"`: 終了（任意）
* `"call"`時の必須フィールド：

  * `target`: str（例 `"math.sqrt"` `"numpy.linalg.norm"`）
  * `args`: list（JSON化可能な値）
  * `kwargs`: dict（任意）

#### レスポンスJSON

* `id`: int（要求と一致）
* `ok`: bool
* `result`: any（成功時、JSON化できる値に限る）
* `error`: str（失敗時、例外メッセージ＋簡易スタック）
* 任意：`error_type`, `traceback`（デバッグ用）

### 4.2 実行モデル（常駐）

* 起動後、無限ループでリクエストを読み続ける。
* 1リクエストごとに以下を行う：

  1. JSONパース
  2. `op` 分岐
  3. 例外捕捉
  4. 1行JSON応答（flush必須）

### 4.3 import管理（遅延import + キャッシュ）

* `modules_cache: Dict[str, module]` を持つ
* `target` からモジュール部を抽出して、未ロードなら import

  * `importlib.import_module(module_name)`
* 2回目以降はキャッシュを利用
* ※初回に “全部import” はしない（要件：未知ライブラリ対応・起動高速化）

### 4.4 target解決

* `target` は基本 `"module.attr1.attr2...func"` を想定
* 解決手順：

  1. moduleを import
  2. `getattr` を連鎖して最終呼び出し対象を得る
  3. callableであることを確認（任意）
  4. `callable(*args, **kwargs)`

### 4.5 結果のシリアライズ制約

* 返せる型は原則 **JSONで表現可能なもの**に限定：

  * None/bool/int/float/str/list/dict
* JSON化できない型（例：numpy配列、datetime、bytesなど）は初期段階ではエラーとし、

  * 将来拡張として変換（例：`tolist()`, ISO8601, base64）を検討

---

## 5. Tsuchinoko側（トランスパイラ）の変換要件

### 5.1 どこをPythonに逃がすか（変換ポリシー）

* 「Rust標準/サポート済みAPIで置換できるもの」はRustにする
* 「未サポートのimport依存・ライブラリ依存の呼び出し」は **PythonBridge呼び出し**に置換

  * 例：`math.sqrt(5)` → `py.call_f64("math.sqrt", [5])` 的な呼び出し

### 5.2 型付き出力（Rust型への落とし込み）

* Tsuchinokoは型ヒントを使うので、以下を行う：

  * Python側の戻り型を推定（型ヒントまたは既知関数表）
  * Rust側で `call_<type>` を選ぶ（例 `call_i64`, `call_f64`, `call_string`, `call_vec_i64`）
* 型不明の場合は：

  * 最初は `serde_json::Value` 相当で受け、呼び出し側で変換（またはエラー）

### 5.3 import文の扱い

* Python側で実importするため、Rust側にその依存情報を渡す方式を定義：

  * **方式A（推奨）**：import文は“無視してよい”。target呼び出し時に遅延import
  * **方式B**：起動時に `preload: ["math","numpy"]` をワーカーへ送ってimportさせる（高速化）

---

## 6. ランタイム要件（環境・設定）

### 6.1 Python実行環境の指定

* 変換後実行時に、使用するPythonを決定できる：

  * 設定ファイル、環境変数、CLI引数（優先順位を定義）
* 目的は「ユーザーの環境差で壊れない」こと。
* 将来的に venv/uv を使った固定化も視野。

### 6.2 バッファリング無効化

* `python -u` を必須（要件）
* ワーカーは stdout への応答時 `flush=True` 相当の動作が必須

### 6.3 ワーカーの寿命

* Rustプロセスの寿命＝ワーカー寿命
* Rust異常終了時のワーカー残留を最小化（kill on drop）

---

## 7. 信頼性要件

### 7.1 再起動戦略

* Rust側がワーカー死亡を検知したら：

  * 1回だけ再起動
  * 同じリクエストを再送
  * それでも失敗ならエラー

### 7.2 タイムアウト

* 呼び出し単位でタイムアウト設定（任意）
* デッドロック防止（ワーカーが応答しないケース）

### 7.3 例外・エラーの透明性

* Python例外はRustへ文字列で返す
* 可能なら traceback も返す（デバッグ用）

---

## 8. セキュリティ要件（最低限）

* ワーカーが任意のPythonコード評価（`eval`/`exec`）をしないこと
* Rust→Pythonへ渡すのは「target + args/kwargs」のみ
* `target` に許可リスト（allowlist）を導入可能（任意）

  * 例：`math.*` `numpy.*` だけ許可、など

---

## 9. 性能要件（狙い）

* 単発起動（`python -c`毎回）方式と比べて、

  * **Python起動＋importの固定費を1回にする**
  * 小さい呼び出しを多数回行う場合に大幅有利
* ただし、呼び出しごとに

  * JSONシリアライズ/デシリアライズ
  * プロセス間通信（パイプ）
    のオーバーヘッドがあるため、
  * 大量データは将来バイナリ転送方式へ拡張余地を残す

---

## 10. 受け入れ条件（Acceptance Criteria）

最低限、以下が通れば「B案は実装できた」と言える：

1. 変換後Rustが起動時にPythonワーカーを起動し、終了まで保持できる
2. `math.sqrt(5)` 相当の呼び出しをRustから投げて正しい結果が返る
3. 連続1000回呼び出してもハングせず、stdoutが壊れない（ログ混入なし）
4. Python例外がRustへ `ok:false` で戻り、エラー内容が読める
5. ワーカーをkillしてもRustが検知して1回再起動できる（任意だが実用性が跳ねる）

---

必要なら次に、「Tsuchinokoの変換規則」として
**どのAST/IRノードが `py.call_*()` に置換されるか（判定ロジック）** を仕様として起こせる。
このB案は「import対応」だけじゃなく、将来的に **“未サポート構文の避難所”** にもなるから、設計として強い。
