# Tsuchinoko v1.5.2 要件定義書

> **バージョン**: v1.5.2  
> **作成日**: 2026-01-05  
> **目標リリース**: v1.5.0 完了後

---

## 1. 目的

Python の例外チェーン機能 `raise NewError from OriginalError` を Rust に変換可能にする。

これにより、ライブラリ開発者が Tsuchinoko を使用して、
エラーの原因追跡が可能な品質の高いコードを生成できるようになる。

---

## 2. スコープ

### 2.1 対象機能

| 機能 | 説明 |
|------|------|
| `raise NewError from e` | 新しい例外を生成し、原因として元の例外を保持 |
| `try/except/else` | 例外が発生しなかった場合のブロック (EX-006) |
| Result 型への統一 | 例外が発生し得る関数は `Result<T, E>` を返す |
| エラーチェーン表示 | デバッグ時に原因の連鎖を確認可能 |
| エラーメッセージ改善 | Python 行番号と修正案を表示 |
| 型推論精度向上 | 関数戻り値型の追跡による推論精度改善 |

### 2.2 対象外

| 機能 | 理由 |
|------|------|
| 完全な traceback 再現 | v1.6.0 以降で検討 |
| カスタム例外クラス定義 | 別途検討 |

---

## 3. 変換仕様

### 3.1 raise from 構文

**入力（Python）**:
```python
try:
    value = int("abc")
except ValueError as e:
    raise RuntimeError("変換に失敗しました") from e
```

**出力（Rust）**:
```rust
match int_parse("abc") {
    Ok(v) => Ok(v),
    Err(original) => {
        Err(TsuchinokoError::new(
            "RuntimeError",
            "変換に失敗しました",
            Some(original),
        ))
    }
}
```

### 3.2 関数の戻り値型

例外が発生する可能性のある関数は、呼び出し元も含めて `Result` を返す。

**入力（Python）**:
```python
def outer():
    inner()

def inner():
    try:
        dangerous()
    except ValueError:
        pass
```

**出力（Rust）**:
```rust
fn outer() -> Result<(), TsuchinokoError> {
    inner()
}

fn inner() -> Result<(), TsuchinokoError> {
    match dangerous() {
        Ok(_) => Ok(()),
        Err(_) => Ok(()),  // except ValueError: pass
    }
}
```

### 3.3 エラー型

**原則**: Python の例外（raise / raise from）は `TsuchinokoError` で表現する。
`anyhow::Error` は Rust 内部エラー（I/O 等）の補助用途とする。

```rust
/// Python 例外を表現するエラー型
struct TsuchinokoError {
    kind: String,      // "ValueError", "RuntimeError" など
    message: String,
    cause: Option<Box<TsuchinokoError>>,
}

impl TsuchinokoError {
    fn new(kind: &str, msg: &str, cause: Option<TsuchinokoError>) -> Self {
        Self {
            kind: kind.to_string(),
            message: msg.to_string(),
            cause: cause.map(Box::new),
        }
    }
}
```

---

## 4. 技術設計

### 4.1 AST 変更

```rust
// 現在
Stmt::Raise {
    exception_type: String,
    message: Expr,
}

// v1.5.2
Stmt::Raise {
    exception_type: String,
    message: Expr,
    cause: Option<Box<Expr>>,  // 追加: from 句
}

// 現在
Stmt::TryExcept {
    try_body: Vec<Stmt>,
    except_clauses: Vec<ExceptClause>,
    finally_body: Option<Vec<Stmt>>,
}

// v1.5.2
Stmt::TryExcept {
    try_body: Vec<Stmt>,
    except_clauses: Vec<ExceptClause>,
    else_body: Option<Vec<Stmt>>,     // 追加: else ブロック
    finally_body: Option<Vec<Stmt>>,
}
```

### 4.2 IR 変更

```rust
// IR は Python の意味を保持（Rust 実装詳細を含めない）
IrNode::Raise {
    exc_type: String,
    message: Box<IrExpr>,
    cause: Option<Box<IrExpr>>,  // 追加
}
```

### 4.3 Emitter 変更

- anyhow クレートを依存に追加
- `use anyhow::{Error, Context, Result};` を生成
- `IrNode::Raise` を `Err(...)` 形式に変換
- 関数の戻り値型を `Result<T, Error>` に変更

---

## 5. 成功基準

| # | 基準 | 検証方法 |
|---|------|----------|
| 1 | `raise A from B` 構文がパースできる | パーサーテスト |
| 2 | 生成コードに原因情報が含まれる | 生成 Rust コード確認 |
| 3 | エラー表示に原因チェーンが出る | 実行時出力確認 |
| 4 | ネストした関数呼び出しがコンパイル通る | rustc 成功 |
| 5 | `try/except/else` がパース・変換できる | システムテスト |
| 6 | 既存リグレッションテスト全パス | 62テスト + 新規 |

### 5.1 エラー表示の最低保証

例外出力には **最上位エラーの message** と **少なくとも1段階の cause の message** が含まれること。

```
Error: RuntimeError: 変換に失敗しました
Caused by: ValueError: invalid literal for int() with base 10: 'abc'
```

---

## 6. 変更対象ファイル

| ファイル | 変更内容 |
|----------|----------|
| `src/parser/ast.rs` | `Stmt::Raise` に `cause` フィールド追加 |
| `src/parser/mod.rs` | `raise ... from ...` 構文パース対応 |
| `src/ir/nodes.rs` | `IrNode::Raise` に `cause` フィールド追加 |
| `src/semantic/analyze_statements.rs` | 関数の戻り値型を Result に変換 |
| `src/emitter/mod.rs` | anyhow 依存、Result 生成、エラーチェーン出力 |

---

## 7. スケジュール

| 日 | 作業内容 |
|----|----------|
| 1 | パーサー: raise from 構文対応 |
| 2 | セマンティック: Result 型推論 |
| 3 | エミッター: anyhow コード生成 |
| 4 | テスト作成・デバッグ |
| 5 | ドキュメント更新・リリース準備 |

---

## 8. リスク

| リスク | 対策 |
|--------|------|
| 既存コードの破壊 | try-except を含まない関数も、呼び出し関係上必要な場合は Result に昇格する（ユーザーコードの意味は変えない） |
| Result 伝播の複雑化 | 段階的に実装、シンプルなケースから検証 |
